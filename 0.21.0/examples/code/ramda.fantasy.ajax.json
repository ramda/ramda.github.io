{"title":"Use ramda-fantasy Future to wrap AJAX","description":null,"source":"var Future = require('ramda-fantasy').Future;\n// Wrap ajax in a future\n//  fetch :: String -> Future String\nvar fetch = function(url) {\n  return new Future(function(rej, res) {\n    var oReq = new XMLHttpRequest();\n    oReq.addEventListener('load', res, false);\n    oReq.addEventListener('error', rej, false);\n    oReq.addEventListener('abort', rej, false);\n    oReq.open('get', url, true);\n    oReq.send();\n  });\n};\n\n// Could use Either instead of Future but they work about the same.\n//  parseJSON :: String -> Future Object\nvar parseJSON = function(str) {\n  return new Future(function(rej, res) {\n    try {\n      res(JSON.parse(str));\n    } catch (err) {\n      rej({ error: 'json parse error' });\n    }\n  });\n};\n\n// We have\n// String -> Future String\n// And\n// String -> Future Object\n// So we can .chain() them together\nvar fetchJSON = fetch.chain(parseJSON);\n\n// Get the items out of it?\n//  fetchItems :: Future Object -> Future []\nvar fetchItems = fetchJSON.map(R.prop('items'));\n\n// BTW at this point in the code the request still hasn't been sent\n\n// Filter the response?\n// Have to map first to get at the contents of the future then filter\n//  fetchNewItems :: Future [Object] -> Future [Object]\nvar fetchNewItems = fetchItems.map(R.filter(R.prop('new')));\n\n// Just get the titles of the items\n//  getNewTitles :: Future [Object] -> Future [String]\nvar getNewTitles = fetchNewItems.map(R.map('title'));\n\n// Finally do something\ngetNewTitles('/products.json').fork(console.error, console.log);\n// Now the AJAX req is sent and will log success or failure to console.\n\n// Bonus: Make one ajax request dependent on another\nfetchDependent = fetchJSON.map(R.prop('url')).chain(fetch);\nfetchDependent('urls.json').fork(console.error, console.log);\n"}